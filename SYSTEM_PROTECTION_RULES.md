# 🛡️ システム保護・開発負債管理ルール

## 🎯 基本理念

**「完成した機能を絶対に壊さない」「開発負債を計画的に整理する」**

---

## 🔒 完成機能保護ルール（最重要）

### ✅ 完成機能の定義
```
以下の条件を満たした機能は「完成機能」として保護対象:
1. ユーザーから「修正完了」の確認を得た機能
2. 動作テストを通過し、承認された機能  
3. GitHubに保存済みの安定版機能
4. 本番運用中で問題なく稼働している機能
```

### 🛡️ 保護対象の明確化
```
現在の完成機能（保護必須）:
✅ Step1: 顧客・案件選択機能
✅ Step2: 配送先入力機能  
✅ Step3: 車両選択機能
✅ Step4: スタッフ入力機能（動的ラベル更新含む）
✅ Step5: その他サービス機能（養生作業フロア計算含む）
✅ Step6: 内容確認・PDF出力機能
✅ マスターデータAPI連携機能
✅ データベース構造・マイグレーション
```

### 📋 新規修正時の必須手順
```
Step 1: 影響範囲分析（必須）
├── 修正対象機能の特定
├── 依存関係のある機能リストアップ  
├── データベース変更の影響確認
└── 既存API呼び出し部分の確認

Step 2: 保護戦略決定（必須）
├── 完成機能への影響「あり/なし」判定
├── 影響ありの場合 → 追加保護措置検討
├── バックアップポイント設定
└── ロールバック手順準備

Step 3: 段階的実装（必須）
├── 新機能は独立したファイル・関数で実装
├── 既存コードの最小限変更
├── 完成機能との結合は最終段階で実施
└── 各段階でテスト実行

Step 4: 完成機能テスト（必須）  
├── 修正後に全完成機能の動作確認
├── データ整合性確認
├── API レスポンス確認
└── エラーケース動作確認
```

---

## 📊 開発負債管理ルール

### 🎯 開発負債の定義・分類
```
🔴 Critical（即座対応必要）
- セキュリティ脆弱性
- データ損失リスク
- システム停止要因
- 重大なパフォーマンス問題

🟡 Major（計画的対応必要）
- 重複コード・ファイル
- 未使用ライブラリ・依存関係
- 不適切な設計パターン
- ドキュメント不備

🟢 Minor（余裕がある時対応）
- コードスタイル統一
- 変数名・関数名改善  
- コメント追加・改善
- リファクタリング機会
```

### 🧹 負債整理の安全手順
```
Phase 1: 負債の棚卸し・優先順位付け
├── 全ファイル・機能の負債レベル確認
├── Critical → Major → Minor の順で整理計画
├── 各負債の影響範囲分析
└── 整理スケジュール策定

Phase 2: 安全な整理実行
├── 完成機能に影響しない負債から着手
├── 一つずつ段階的に整理（一度に複数禁止）
├── 整理後は必ず全機能テスト実行
└── 問題発生時は即座にロールバック

Phase 3: 整理結果の検証・記録
├── システム全体の動作確認
├── パフォーマンス改善効果測定
├── 整理内容の文書化
└── 次回整理計画への反映
```

---

## 🔍 影響範囲分析ガイド

### 📊 機能間依存関係マップ
```
Core Dependencies（絶対に影響させてはいけない）:
├── database_schema ← 全機能が依存
├── master_settings API ← Step4, Step5が依存  
├── session_storage管理 ← 全Stepが依存
└── PDF生成機能 ← Step6が依存

Step Dependencies（慎重な変更が必要）:
├── Step1 → Step2, Step3, Step4, Step5, Step6
├── Step2 → Step3, Step4, Step5, Step6
├── Step3 → Step4, Step5, Step6
├── Step4 → Step5, Step6
├── Step5 → Step6
└── Step6 → PDF出力, データ保存

File Dependencies（ファイルレベルでの依存）:
├── src/index.tsx ← メインアプリケーション
├── public/static/app-*.js ← 全UI機能  
├── wrangler.jsonc ← データベース接続
└── ecosystem.config.cjs ← サービス起動
```

### ⚠️ 高リスク変更パターン
```
🚫 絶対避けるべき変更:
- データベーススキーマの破壊的変更
- APIエンドポイントのURL・レスポンス形式変更
- sessionStorageのキー名変更
- 既存機能のHTML要素ID変更

⚠️ 慎重に行うべき変更:
- 既存関数のパラメータ変更
- CSSクラス名変更  
- 設定ファイルの値変更
- ライブラリバージョンアップ

✅ 比較的安全な変更:
- 新機能の独立実装
- コメント・ドキュメント追加
- ログ出力の改善
- 未使用コードの削除（影響範囲確認後）
```

---

## 🧪 テスト戦略・検証ルール

### 📋 必須テスト項目
```
🔄 基本動作テスト（修正後毎回実行）
├── [ ] 全Step（1-6）の画面表示確認
├── [ ] Step間遷移の正常動作確認
├── [ ] データ保存・読み込み確認
├── [ ] マスターデータAPI応答確認
├── [ ] PDF出力機能動作確認
└── [ ] エラーハンドリング動作確認

📊 データ整合性テスト（DB変更時実行）  
├── [ ] 既存データの読み込み確認
├── [ ] 新規データ保存確認
├── [ ] マスター設定値の正常取得確認
├── [ ] 計算結果の正確性確認
└── [ ] データマイグレーション正常性確認

🎨 UI/UX回帰テスト（UI変更時実行）
├── [ ] 動的ラベル更新機能確認
├── [ ] 養生作業フロア計算確認  
├── [ ] AI最適化機能確認
├── [ ] フォーム入力・バリデーション確認
└── [ ] レスポンシブデザイン確認
```

### 🔧 自動テスト環境
```
📱 ブラウザテスト
├── Chrome DevTools でのコンソールエラー確認
├── Network タブでのAPI通信確認  
├── Performance タブでの速度測定
└── Application タブでのStorage確認

⚡ サーバーテスト
├── curl コマンドでのAPI動作確認
├── PM2 logs でのエラー監視
├── npm run build での ビルド確認
└── Database接続テスト
```

---

## 🎛️ 開発負債整理の実践ルール

### 🗂️ ファイル・コード整理戦略
```
Priority 1: 安全性重視
├── 重複ファイルの統合（テスト済み機能のみ）
├── 未使用インポートの削除
├── デッドコード（到達不可能コード）の除去
└── 一時的なテストファイルの整理

Priority 2: 保守性向上
├── 変数名・関数名の統一
├── コメント・ドキュメント充実
├── 設定値の外部ファイル化
└── エラーメッセージの統一

Priority 3: パフォーマンス改善
├── 不要な依存関係削除
├── バンドルサイズ最適化
├── API呼び出し回数削減
└── キャッシュ戦略改善
```

### 📋 負債整理チェックリスト
```
🔍 事前確認（整理前必須）
├── [ ] 整理対象ファイル・機能の影響範囲分析完了
├── [ ] 完成機能への影響「なし」確認完了
├── [ ] バックアップ作成完了（ローカル + GitHub）
├── [ ] ロールバック手順準備完了
└── [ ] テスト項目リスト作成完了

🛠️ 整理実行（段階的実行）
├── [ ] 一つの負債のみを対象に実行
├── [ ] 変更範囲を最小限に限定
├── [ ] 中間テストポイントでの動作確認
├── [ ] 問題発生時の即座停止・復旧
└── [ ] 整理内容の詳細記録

✅ 事後確認（整理後必須）
├── [ ] 全完成機能の動作確認完了
├── [ ] データベース整合性確認完了  
├── [ ] API応答・パフォーマンス確認完了
├── [ ] エラーログ・警告メッセージ確認完了
└── [ ] 整理効果測定・記録完了
```

---

## 🚨 緊急事態対応ルール

### 🔴 完成機能破損時の対応
```
Step 1: 即座停止・現状保持
├── 作業を即座に中断
├── 現在の状態をローカルで保持  
├── 破損範囲・原因の特定
└── ユーザーへの緊急報告

Step 2: 復旧方法の検討・実行
├── バックアップからの部分復元
├── Git履歴からの特定ファイル復元
├── 手動でのコード修正
└── データベースの部分ロールバック

Step 3: 復旧後の検証・再発防止  
├── 全機能の動作確認
├── データ整合性確認
├── 破損原因の根本分析
└── 再発防止策の実装
```

### 🟡 開発負債整理失敗時の対応
```
Level 1: 軽微な問題
├── 該当変更のみ取り消し
├── 影響範囲の限定確認
├── 部分的な修正で対応
└── 継続的な監視

Level 2: 重大な問題  
├── 直前のGitHubバックアップに完全復元
├── 全システムの動作確認
├── 負債整理計画の見直し
└── より慎重な整理戦略への変更
```

---

## 📈 継続改善・監視ルール

### 📊 定期健康診断
```
🗓️ 日次確認
├── PM2プロセス正常性確認
├── エラーログ監視
├── 主要API応答時間確認
└── データベース接続状況確認

🗓️ 週次確認  
├── 全機能動作テスト実行
├── 新規発生負債の特定・記録
├── パフォーマンス測定・比較
└── セキュリティ脆弱性スキャン

🗓️ 月次確認
├── 完成機能の網羅的テスト
├── 開発負債整理計画見直し
├── システム全体アーキテクチャ確認  
└── バックアップ戦略有効性確認
```

### 🎯 品質指標・目標値
```
📈 システム安定性指標
├── 完成機能破損率: 0% （目標・維持）
├── 重要API応答時間: <500ms （目標）
├── ページ読み込み時間: <2s （目標）
└── エラー発生率: <0.1% （目標）

📊 開発負債指標
├── Critical負債: 0件 （常時維持）
├── Major負債: 月1件以下処理 （目標）  
├── 重複ファイル数: 5件以下 （目標）
└── 未使用依存関係: 0件 （目標）
```

---

## ✅ 実装ガイドライン

### 🛡️ 新機能開発時の保護戦略
```
設計段階:
├── 既存機能への影響ゼロ設計
├── 独立したファイル・モジュール構成
├── 既存APIの拡張（非破壊的変更）
└── データベースの追加のみ（既存テーブル保護）

実装段階:
├── 新機能部分のみ実装・テスト
├── 既存機能との結合は最終段階
├── 段階的統合・テスト
└── 問題発生時の即座分離

統合段階:
├── 既存機能への影響範囲最小化
├── 統合前後での全機能テスト
├── データマイグレーション慎重実行
└── 統合後の継続監視
```

このルールにより、**完成した機能を絶対に壊さず、開発負債を計画的に整理し、システム全体の安定性を保ちながら発展させる**ことができます。